<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta
  name="theme-color"
  content="#ffffff"
  media="(prefers-color-scheme: light)"
/>
<meta
  name="theme-color"
  content="#000000"
  media="(prefers-color-scheme: dark)"
/>
<link rel="manifest" href="manifest.json" />
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    background-color: #fff;
    color: #161616;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      color: #fff;
    }
  }

  article {
    outline: none;
    padding: 18px max(18px, calc(50vw - 400px));
    width: 100%;
    min-height: 100vh;
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }
</style>
<article contenteditable="plaintext-only" spellcheck></article>
<script>
  const article = document.querySelector("article");
  article.addEventListener("input", debounce(500, save));
  article.addEventListener("blur", save);
  addEventListener("DOMContentLoaded", load);
  addEventListener("hashchange", load);

  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js");
  }

  console.log(
    "%cGitHub https://github.com/antonmedv/textarea",
    "font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ",
  );

  async function load() {
    try {
      if (location.hash !== "") await set(location.hash);
      else {
        await set(localStorage.getItem("hash") ?? "");
        if (article.textContent) history.replaceState({}, "", await get());
        article.focus();
      }
    } catch (e) {
      article.textContent = "";
      article.focus();
    }
  }

  async function save() {
    const hash = await get();
    if (location.hash !== hash) history.replaceState({}, "", hash);
    try {
      localStorage.setItem("hash", hash);
    } catch (e) {}
  }

  async function set(hash) {
    if (!hash) return;
    const content = await decompress(hash.slice(1));
    article.textContent = content;
  }

  async function get() {
    const content = article.textContent;
    return "#" + (await compress(content));
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string);
    const stream = new CompressionStream("deflate-raw");
    const writer = stream.writable.getWriter();
    writer.write(byteArray);
    writer.close();
    const buffer = await new Response(stream.readable).arrayBuffer();
    return new Uint8Array(buffer).toBase64({ alphabet: "base64url" });
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, { alphabet: "base64url" });
    const stream = new DecompressionStream("deflate-raw");
    const writer = stream.writable.getWriter();
    writer.write(byteArray);
    writer.close();
    const buffer = await new Response(stream.readable).arrayBuffer();
    return new TextDecoder().decode(buffer);
  }

  function debounce(ms, fn) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), ms);
    };
  }
</script>
